{"version":3,"file":"main.bundle.js","sources":["../src/scripts/utils/utils.js","../src/scripts/utils/helpers/lazy-media.js","../src/scripts/components/reload-on-event.js","../src/scripts/components/responsive-video.js","../src/scripts/utils/helpers/theme-helpers.js","../src/entrypoints/theme.js"],"sourcesContent":["/**\n * Returns a function that as long as it continues to be invoked, won't be triggered.\n * @param {Function} fn - Callback function.\n * @param {number} [wait=300] - Delay (in milliseconds).\n * @returns {Function}\n */\nexport function debounce(fn, wait = 300) {\n    let t;\n    return (...args) => {\n        clearTimeout(t);\n        t = setTimeout(() => fn.apply(this, args), wait);\n    };\n}\n\n/**\n * Transforms a string from kebab-case to PascalCase.\n * @param {string} str - The input string in kebab-case.\n * @returns {string} - The transformed string in PascalCase.\n */\nexport function kebabToPascalCase(str) {\n    return str\n        .split('-') // Split the string by hyphens\n        .map((word) => word.charAt(0).toUpperCase() + word.slice(1)) // Capitalize the first letter of each word\n        .join(''); // Join the words back together\n}\n\n/**\n * Logs a message to the DOM by creating an <h4> element with the message,\n * appending it to the body, and removing it after a specified delay.\n *\n * @param {string} message - The message to display in the <h4> element.\n * @param {number} [delay=3000] - The delay in milliseconds before removing the <h4> element. Default is 3000ms.\n */\nexport function logDOM(message, delay = 8000) {\n    if (window.Shopify.theme.role != 'development') return;\n    const h4 = document.createElement('h4');\n    h4.textContent = message;\n    h4.style.color = 'red';\n\n    const logDomContainer = document.querySelector('[data-dom-log]') || document.body;\n\n    logDomContainer.prepend(h4);\n\n    setTimeout(() => {\n        logDomContainer.removeChild(h4);\n    }, delay);\n}\n\n/**\n * Waits for the animation to end on the specified element.\n *\n * @param {HTMLElement} element - The element to wait for the animation to end on.\n * @param {Function} [callback] - Optional callback function to execute when the animation ends.\n * @returns {Promise<void>} A promise that resolves when the animation ends.\n */\nexport async function afterAnimationEnd(element, callback) {\n    return new Promise((resolve) => {\n        function onEnd(event) {\n            if (event.target !== element) return;\n\n            element.removeEventListener('animationend', onEnd);\n            element.removeEventListener('transitionend', onEnd);\n\n            if (typeof callback === 'function') {\n                callback();\n            } else {\n                console.warn('callback was not valid function', callback);\n            }\n\n            resolve();\n        }\n\n        element?.addEventListener('animationend', onEnd);\n        element?.addEventListener('transitionend', onEnd);\n    });\n}\n\n/**\n * Executes the provided callback function after the current call stack has cleared.\n *\n * @param {Function} callback - The function to be executed after the call stack clears.\n */\nexport function afterCallstack(callback, delay = 0) {\n    setTimeout(() => {\n        requestAnimationFrame(callback);\n    }, delay);\n}\n\nexport function formatMoney(cents, format = window.themeVariables.moneyFormat) {\n    if (typeof cents == 'string') {\n        cents = cents.replace('.', '');\n    }\n    let value = '';\n    const placeholderRegex = /\\{\\{\\s*(\\w+)\\s*\\}\\}/;\n\n    function formatWithDelimiters(number, precision = 2, thousands = ',', decimal = '.') {\n        if (isNaN(number) || number == null) {\n            return 0;\n        }\n\n        number = (number / 100.0).toFixed(precision);\n\n        const parts = number.split('.'),\n            dollars = parts[0].replace(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/g, `$1${thousands}`),\n            cents = parts[1] ? decimal + parts[1] : '';\n\n        return dollars + cents;\n    }\n\n    switch (format.match(placeholderRegex)[1]) {\n        case 'amount':\n            value = formatWithDelimiters(cents, 2);\n            break;\n        case 'amount_no_decimals':\n            value = formatWithDelimiters(cents, 0);\n            break;\n        case 'amount_with_comma_separator':\n            value = formatWithDelimiters(cents, 2, '.', ',');\n            break;\n        case 'amount_no_decimals_with_comma_separator':\n            value = formatWithDelimiters(cents, 0, '.', ',');\n            break;\n    }\n\n    return format.replace(placeholderRegex, value);\n}\n\nexport function truncateText(text, maxLength) {\n    if (text.length <= maxLength) return text;\n    return text.slice(0, maxLength) + '...';\n}\n","import { afterCallstack } from '../utils.js';\n\n// Constants for load attributes\nconst LOAD_ATTRIBUTES = {\n    DOM: 'data-load-dom',\n    LOAD: 'data-load-load',\n    MANUAL: 'data-load-manual'\n};\n\nconst SELECTORS = {\n    LAZY_MEDIA: '[loading=\"lazy\"], [data-src], [data-poster], [data-srcset]',\n    PICTURE: 'PICTURE'\n};\n\nconst DEBUG = false;\n\n/**\n * Sets src, srcset, and poster attributes from data attributes for an element\n * @param {Element} el - Element to set attributes on\n */\nfunction setMediaAttr(el) {\n    if (el.dataset.src && !el.src) {\n        el.src = el.dataset.src;\n    }\n\n    if (el.dataset.srcset && !el.srcset) {\n        el.srcset = el.dataset.srcset;\n    }\n\n    if (el.dataset.poster && !el.poster) {\n        el.poster = el.dataset.poster;\n    }\n}\n\n/**\n * Checks if a lazy load media element has alternate <source> elements and copies the\n * 'data-src' and 'data-srcset' selectors to 'src' and 'srcset' accordingly.\n * @param {Element} media - Media element (image or video).\n */\nexport function setMediaSources(media) {\n    if (!media) {\n        console.warn('[LazyMedia] Invalid media element provided');\n        return;\n    }\n\n    try {\n        if (media.parentNode?.tagName === SELECTORS.PICTURE) {\n            Array.from(media.parentNode.children).forEach((el) => {\n                setMediaAttr(el);\n            });\n        } else {\n            setMediaAttr(media);\n        }\n    } catch (error) {\n        console.error('[LazyMedia] Error setting media sources:', error);\n    }\n}\n\nfunction setMediaSourceArray(mediaElArray) {\n    return mediaElArray.forEach((media) => setMediaSources(media));\n}\n\n/**\n * Initialises lazy load media (images and videos).\n */\nexport function initLazyMedia() {\n    // Handle media elements with specific load timing first\n    const mediaOnDOMLoad = [];\n    const mediaOnLoad = [];\n    const mediaForIntersectionObserver = [];\n\n    document.querySelectorAll(SELECTORS.LAZY_MEDIA).forEach((media) => {\n        if (media.hasAttribute(LOAD_ATTRIBUTES.DOM)) {\n            mediaOnDOMLoad.push(media);\n        } else if (media.hasAttribute(LOAD_ATTRIBUTES.LOAD)) {\n            mediaOnLoad.push(media);\n        } else if (media.hasAttribute(LOAD_ATTRIBUTES.MANUAL)) {\n            return; // Skip manual loading media\n        } else {\n            // Media elements without specific load timing\n            if ('loading' in HTMLImageElement.prototype === false && 'IntersectionObserver' in window) {\n                mediaForIntersectionObserver.push(media);\n            } else {\n                setMediaSources(media);\n            }\n        }\n    });\n\n    // Load media with specific timing\n    loadMediaOnDOMLoaded(mediaOnDOMLoad);\n    loadMediaOnLoaded(mediaOnLoad);\n\n    // Use IntersectionObserver for remaining media if supported\n    if (mediaForIntersectionObserver.length > 0) {\n        const io = new IntersectionObserver(\n            (entries, observer) => {\n                entries.forEach((entry) => {\n                    if (entry.isIntersecting) {\n                        const media = entry.target;\n                        setMediaSources(media);\n                        observer.unobserve(media);\n                    }\n                });\n            },\n            { rootMargin: '0px 0px 500px 0px' }\n        );\n\n        mediaForIntersectionObserver.forEach((media) => {\n            io.observe(media);\n        });\n    }\n}\n\nfunction loadMediaOnDOMLoaded(mediaElArray) {\n    if (DEBUG) console.debug('loadMediaOnDOMLoaded', mediaElArray);\n    const execute = () => afterCallstack(() => setMediaSourceArray(mediaElArray));\n\n    if (document.readyState != 'loading') {\n        return execute();\n    }\n\n    document.addEventListener('DOMContentLoaded', execute);\n}\n\nfunction loadMediaOnLoaded(mediaElArray) {\n    if (DEBUG) console.debug('loadMediaOnLoaded', mediaElArray);\n    const execute = () => afterCallstack(() => setMediaSourceArray(mediaElArray));\n\n    if (document.readyState == 'complete') {\n        return execute();\n    }\n\n    window.addEventListener('load', execute);\n}\n\n/**\n * Loads all media elements manually (load, dom, manual, etc.)\n * @param {Document|Element} container - Container to search within\n */\nexport function loadManualMedia(container = document) {\n    if (DEBUG) console.debug('loadManualMedia', container);\n    try {\n        const mediaEls = container.querySelectorAll('[loading=\"lazy\"]');\n        setMediaSourceArray(mediaEls);\n    } catch (error) {\n        console.error('[LazyMedia] Error loading manual media:', error);\n    }\n}\n\nafterCallstack(initLazyMedia);\ndocument.addEventListener('DOMContentLoaded', initLazyMedia);\n\ndocument.addEventListener('shopify:section:load', () => afterCallstack(initLazyMedia));\n\n// For backwards compatibility\nexport const setImageSources = setMediaSources;\nexport const initLazyImages = initLazyMedia;\nexport const loadManualImages = loadManualMedia;\n","import { initLazyImages } from '../utils/helpers/lazy-media.js';\nimport { afterCallstack } from '../utils/utils.js';\n\n//chrom console: -url:https://au.timeresistance.com/cdn/shopifycloud/shopify-xr-js/v1.0/shopify-xr.en.js -url:chrome-extension://hdokiejnpimakedhajhdlcegeplioahd/background-redux-new.js -url:https://au.timeresistance.com/cdn/shopifycloud/media-analytics/v0.1/analytics.js -runtime.lastError -ERR_BLOCKED\nclass ReloadOnEvent extends HTMLElement {\n    static sectionListeners = {};\n\n    constructor() {\n        super();\n    }\n\n    static registerSectionListener(sectionId, event, callback) {\n        if (!this.sectionListeners[event]) {\n            const listener = document.addEventListener(event, (eventData) => {\n                this.handleEvent(event, eventData);\n            });\n\n            this.sectionListeners[event] = {\n                listener,\n                sections: {}\n            };\n        }\n\n        const sectionListener = this.sectionListeners[event];\n\n        if (!sectionListener.sections[sectionId]) {\n            sectionListener.sections[sectionId] = [];\n        }\n\n        sectionListener.sections[sectionId].push(callback);\n    }\n\n    static async handleEvent(event, eventData) {\n        const sectionIds = Object.keys(this.sectionListeners[event].sections);\n\n        const url = new URL(window.location.href);\n\n        if (eventData?.detail?.variant) {\n            url.searchParams.set('variant', eventData.detail.variant.id);\n        }\n\n        url.searchParams.set('sections', sectionIds.join(','));\n\n        const sectionJSON = await this.fetchSectionHTML(url);\n\n        sectionIds.forEach((sectionId) => {\n            const sectionListener = this.sectionListeners[event].sections[sectionId];\n\n            sectionListener.forEach((callback) => {\n                callback(sectionJSON[sectionId]);\n            });\n        });\n    }\n\n    static async fetchSectionHTML(url) {\n        const sectionJSON = await fetch(url).then((res) => res.json());\n\n        return sectionJSON;\n    }\n\n    static unregisterSectionListener(sectionId, event) {\n        const sectionListener = this.sectionListeners[event];\n\n        delete sectionListener.sections[sectionId];\n\n        if (Object.keys(sectionListener.sections).length === 0) {\n            document.removeEventListener(event, sectionListener.listener);\n            delete this.sectionListeners[event];\n        }\n    }\n\n    connectedCallback() {\n        this.event = this.getAttribute('data-event');\n\n        if (!this.id) {\n            console.error('ReloadOnEvent: No id attribute found on element');\n            return;\n        }\n\n        this.section = this.closest('.shopify-section');\n        this.sectionId = this.section.id;\n        this.shopifySectionId = this.sectionId.replace('shopify-section-', '');\n\n        if (this.dataset.reloadSection !== 'false') {\n            this.container = this.section.querySelector('[data-section-type]');\n            if (this.container) {\n                this.sectionType = this.container.getAttribute('data-section-type');\n            }\n        }\n\n        ReloadOnEvent.registerSectionListener(\n            this.shopifySectionId,\n            this.event,\n            this.updateSection.bind(this)\n        );\n    }\n\n    disconnectedCallback() {\n        ReloadOnEvent.unregisterSectionListener(this.sectionId, this.event);\n    }\n\n    updateSection(html) {\n        this.setNewHTML(html);\n\n        if (this.container) {\n            this.reloadSection();\n        }\n        afterCallstack(() => {\n            initLazyImages();\n        }, 10);\n\n        this.dispatchEvent(\n            new CustomEvent('reload-on-event:loaded', {\n                bubbles: true,\n                detail: {\n                    sectionId: this.sectionId,\n                    shopifySectionId: this.shopifySectionId\n                }\n            })\n        );\n    }\n\n    reloadSection() {\n        window.Shopify.theme.sections.unload(this.container);\n\n        const newContainer = this.section.querySelector(`[data-section-type=\"${this.sectionType}\"]`);\n\n        if (!newContainer) {\n            console.error(\n                `ReloadOnEvent reload: Failed to find the new container element with type [${this.sectionType}] after updating innerHTML.`\n            );\n\n            return;\n        }\n\n        this.container = newContainer;\n\n        window.Shopify.theme.sections.load(this.sectionType, this.container);\n    }\n\n    async setNewHTML(html) {\n        try {\n            if (!html) {\n                console.error(\n                    'ReloadOnEvent setNewHTML: Fetched HTML is empty or null for section',\n                    this.shopifySectionId\n                );\n                return;\n            }\n\n            const parser = new DOMParser();\n            const doc = parser.parseFromString(html, 'text/html');\n\n            const fetchedSelf = doc.getElementById(this.id);\n\n            if (!fetchedSelf) {\n                console.error(\n                    `ReloadOnEvent: Could not find \"self\" (<reload-on-event id=\"${this.id}\">) element within the fetched section HTML.`\n                );\n            }\n\n            this.innerHTML = fetchedSelf.innerHTML;\n        } catch (error) {\n            console.error('ReloadOnEvent setNewHTML: Error fetching or parsing HTML:', error);\n        }\n    }\n}\n\ncustomElements.define('reload-on-event', ReloadOnEvent);\n","import { initLazyMedia } from '../utils/helpers/lazy-media.js';\n\nconst LOAD_TYPES = {\n    DOM: 'dom',\n    LOAD: 'load',\n    MANUAL: 'manual'\n};\n\nconst VIDEO_ERROR_CODES = {\n    MEDIA_ERR_ABORTED: 1,\n    MEDIA_ERR_NETWORK: 2,\n    MEDIA_ERR_DECODE: 3,\n    MEDIA_ERR_SRC_NOT_SUPPORTED: 4\n};\n\nconst SELECTORS = {\n    VIDEO: 'video',\n    SOURCES_TEMPLATE: 'template[data-sources]',\n    RESPONSIVE_VIDEO_WRAPPER: '.responsive-video-wrapper',\n    POSTER_IMAGE: '.poster-image',\n    PLAY_TOGGLE: '[data-play-toggle]',\n    SOUND_TOGGLE: '[data-sound-toggle]',\n    ICON_PLAY: '[data-icon-play]',\n    ICON_SOUND_ON: '[data-icon-sound-on]',\n    ICON_SOUND_OFF: '[data-icon-sound-off]'\n};\n\nclass ResponsiveVideo extends HTMLElement {\n    constructor() {\n        super();\n        this.onClick = this.onClick.bind(this);\n        this.onResize = this.onResize.bind(this);\n        this.onLoaded = this.onLoaded.bind(this);\n    }\n\n    connectedCallback() {\n        this.lazyType = this.getAttribute('data-lazy-type');\n\n        this.initElements();\n\n        this.sources = this.getSources();\n\n        this.video.style.opacity = '0';\n        this.videoWrapper.addEventListener('click', this.onClick);\n\n        this.video.addEventListener('loadeddata', this.onLoaded);\n\n        window.addEventListener('resize', this.onResize);\n        this.initVideo();\n    }\n\n    initVideo() {\n        this.updateSource();\n\n        const execute = () => {\n            if (this.lazyType) {\n                this.video.setAttribute('data-src', this.currentSource);\n                initLazyMedia();\n            } else {\n                this.load();\n            }\n        };\n\n        if (this.isVisible()) {\n            execute();\n        } else {\n            this.observeVisibility(execute);\n        }\n    }\n\n    isVisible() {\n        const rect = this.getBoundingClientRect();\n        return rect.width > 0 && rect.height > 0;\n    }\n\n    observeVisibility(callback) {\n        const observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting && this.isVisible()) {\n                    // Element is now visible\n                    callback();\n                    observer.disconnect();\n                }\n            });\n        });\n\n        observer.observe(this);\n    }\n\n    initElements() {\n        this.video = this.querySelector(SELECTORS.VIDEO);\n        this.sourcesTemplate = this.querySelector(SELECTORS.SOURCES_TEMPLATE);\n        if (!this.video) return;\n\n        this.poster = this.querySelector(SELECTORS.POSTER_IMAGE);\n\n        this.videoWrapper = this.querySelector(SELECTORS.RESPONSIVE_VIDEO_WRAPPER);\n        this.soundBtn = this.querySelector(SELECTORS.SOUND_TOGGLE);\n\n        this.playIcon = this.querySelector(SELECTORS.ICON_PLAY);\n        this.soundOnIcon = this.querySelector(SELECTORS.ICON_SOUND_ON);\n        this.soundOffIcon = this.querySelector(SELECTORS.ICON_SOUND_OFF);\n    }\n\n    getSources() {\n        return Array.from(this.sourcesTemplate.content.querySelectorAll('source')).map((s) => ({\n            src: s.getAttribute('data-src'),\n            media: s.media\n        }));\n    }\n\n    cleanSourceURL(src) {\n        if (src.startsWith('//')) {\n            src = `${window.location.protocol}${src}`;\n        }\n\n        return new URL(src, window.location.href).href;\n    }\n\n    updateSource() {\n        const match = this.sources.find((s) => s.media && matchMedia(s.media).matches);\n        const fallback = this.sources.find((s) => !s.media);\n        const nextSrc = (match || fallback || this.sources[0]).src;\n\n        if (!nextSrc) return;\n\n        const newSourceUrl = this.cleanSourceURL(nextSrc);\n\n        if (this.video.src) {\n            const currentSourceUrl = this.cleanSourceURL(this.video.src);\n            if (currentSourceUrl === newSourceUrl) return;\n        }\n\n        this.currentSource = nextSrc;\n    }\n\n    load() {\n        if (this.video.src) {\n            const newSourceUrl = this.cleanSourceURL(this.currentSource);\n            const currentSourceUrl = this.cleanSourceURL(this.video.src);\n            if (currentSourceUrl === newSourceUrl) return;\n        }\n\n        this.video.src = this.currentSource;\n    }\n\n    onResize() {\n        clearTimeout(this._resizeTimer);\n        this._resizeTimer = setTimeout(() => {\n            this.updateSource();\n            this.load();\n            const playing = !this.video.paused;\n            playing && this.video.play().catch(() => {});\n        }, 150);\n    }\n\n    onClick(e) {\n        if (e.target.closest('[data-sound-toggle]')) {\n            this.toggleSound();\n        } else {\n            this.togglePlay();\n        }\n    }\n\n    togglePlay() {\n        this.video.paused ? this.video.play().catch(() => {}) : this.video.pause();\n        this.updateControlsUI();\n    }\n\n    toggleSound() {\n        this.video.muted = !this.video.muted;\n        this.updateControlsUI();\n    }\n\n    onLoaded() {\n        if (this.poster) {\n            this.poster.style.opacity = '0';\n        }\n        this.video.style.opacity = '1';\n        if (this.video.hasAttribute('autoplay')) {\n            this.video.muted = true;\n            this.video.play().catch(() => {});\n        }\n        this.updateControlsUI();\n    }\n\n    updateControlsUI() {\n        if (this.playIcon) {\n            this.playIcon.classList.toggle('hidden', !this.video.paused);\n        }\n        if (this.soundOnIcon && this.soundOffIcon) {\n            this.soundOnIcon.classList.toggle('hidden', this.video.muted);\n            this.soundOffIcon.classList.toggle('hidden', !this.video.muted);\n        }\n    }\n\n    disconnectedCallback() {\n        this.removeEventListener('click', this.onClick);\n        this.soundBtn?.removeEventListener('click', this.onSound);\n        this.video.removeEventListener('loadeddata', this.onLoaded);\n        window.removeEventListener('resize', this.onResize);\n    }\n}\n\ncustomElements.define('responsive-video', ResponsiveVideo);\n","document.addEventListener('DOMContentLoaded', () => {\n    document.addEventListener('click', (evt) => {\n        const link = evt.target.tagName === 'A' ? evt.target : evt.target.closest('a');\n        if (link && link.tagName === 'A' && window.location.hostname !== new URL(link.href).hostname) {\n            link.target = '_blank';\n        }\n    });\n\n    // Ensure anchor scrolling is smooth (this shouldn't be added in the CSS)\n    document.addEventListener('click', (evt) => {\n        if (\n            evt.target.tagName === 'A' &&\n            window.location.hostname === new URL(evt.target.href).hostname &&\n            evt.target.href.includes('#')\n        ) {\n            document.getElementsByTagName('html')[0].style.scrollBehavior = 'smooth';\n            setTimeout(() => {\n                document.getElementsByTagName('html')[0].style.scrollBehavior = '';\n            }, 1000);\n        }\n    });\n});\n","// Initialize theme object\nwindow.theme = window.theme || {};\n\nimport '../scripts/components/';\nimport '../scripts/utils/helpers';\n//import '../scripts/legacy/theme-new.js';\n\nconsole.log('main.bundle.js loaded');\n\n// Dispatch event when theme bundle is loaded\ndocument.dispatchEvent(new CustomEvent('theme:loaded'));\nwindow.theme.loaded = true;\n"],"names":["afterCallstack","callback","delay","setTimeout","requestAnimationFrame","LOAD_ATTRIBUTES","SELECTORS","setMediaAttr","el","dataset","src","srcset","poster","setMediaSources","media","_a","parentNode","tagName","Array","from","children","forEach","error","console","warn","setMediaSourceArray","mediaElArray","initLazyMedia","mediaOnDOMLoad","mediaOnLoad","mediaForIntersectionObserver","document","querySelectorAll","hasAttribute","push","HTMLImageElement","prototype","window","loadMediaOnDOMLoaded","execute","readyState","addEventListener","loadMediaOnLoaded","length","io","IntersectionObserver","entries","observer","entry","isIntersecting","target","unobserve","rootMargin","observe","initLazyImages","_ReloadOnEvent","HTMLElement","constructor","registerSectionListener","sectionId","event","this","sectionListeners","listener","eventData","handleEvent","sections","sectionListener","sectionIds","Object","keys","url","URL","location","href","detail","variant","searchParams","set","id","join","sectionJSON","fetchSectionHTML","fetch","then","res","json","unregisterSectionListener","removeEventListener","connectedCallback","getAttribute","section","closest","shopifySectionId","replace","reloadSection","container","querySelector","sectionType","updateSection","bind","disconnectedCallback","html","setNewHTML","dispatchEvent","CustomEvent","bubbles","Shopify","theme","unload","newContainer","load","parser","DOMParser","fetchedSelf","parseFromString","getElementById","innerHTML","ReloadOnEvent","customElements","define","ResponsiveVideo","onClick","onResize","onLoaded","lazyType","initElements","sources","getSources","video","style","opacity","videoWrapper","initVideo","updateSource","setAttribute","currentSource","isVisible","observeVisibility","rect","getBoundingClientRect","width","height","disconnect","sourcesTemplate","soundBtn","playIcon","soundOnIcon","soundOffIcon","content","map","s","cleanSourceURL","startsWith","protocol","match","find","matchMedia","matches","fallback","nextSrc","newSourceUrl","clearTimeout","_resizeTimer","paused","play","catch","e","toggleSound","togglePlay","pause","updateControlsUI","muted","classList","toggle","onSound","evt","link","hostname","includes","getElementsByTagName","scrollBehavior","log","loaded"],"mappings":"oCAkFO,SAASA,eAAeC,SAAUC,MAAQ,GAC7CC,YAAW,KACPC,sBAAsBH,YACvBC,MACP,CCnFA,MAAMG,oBACG,gBADHA,qBAEI,iBAFJA,uBAGM,mBAGNC,uBACU,6DADVA,oBAEO,UASb,SAASC,aAAaC,IACdA,GAAGC,QAAQC,MAAQF,GAAGE,MACnBF,GAAAE,IAAMF,GAAGC,QAAQC,KAGpBF,GAAGC,QAAQE,SAAWH,GAAGG,SACtBH,GAAAG,OAASH,GAAGC,QAAQE,QAGvBH,GAAGC,QAAQG,SAAWJ,GAAGI,SACtBJ,GAAAI,OAASJ,GAAGC,QAAQG,OAE/B,CAOO,SAASC,gBAAgBC,ODvChC,IAAAC,GCwCI,GAAKD,MAKD,KACI,OAAAC,GAAMD,MAAAE,iBAAY,EAAAD,GAAAE,WAAYX,oBAC9BY,MAAMC,KAAKL,MAAME,WAAWI,UAAUC,SAASb,KAC3CD,aAAaC,OAGjBD,aAAaO,MAEpB,OAAQQ,OACGC,QAAAD,MAAM,2CAA4CA,MAC7D,MAdGC,QAAQC,KAAK,6CAerB,CAEA,SAASC,oBAAoBC,cACzB,OAAOA,aAAaL,SAASP,OAAUD,gBAAgBC,QAC3D,CAKO,SAASa,gBAEZ,MAAMC,eAAiB,GACjBC,YAAc,GACdC,6BAA+B,GAwBjC,GAtBJC,SAASC,iBAAiB1B,wBAAsBe,SAASP,QACrD,GAAIA,MAAMmB,aAAa5B,qBACnBuB,eAAeM,KAAKpB,YACb,GAAAA,MAAMmB,aAAa5B,sBAC1BwB,YAAYK,KAAKpB,WACV,IAAAA,MAAMmB,aAAa5B,wBAC1B,OAGI,YAAa8B,iBAAiBC,YAAc,GAAS,yBAA0BC,OAC/EP,6BAA6BI,KAAKpB,OAElCD,gBAAgBC,MAEvB,KA4BT,SAASwB,qBAAqBZ,cAE1B,MAAMa,QAAU,IAAMvC,gBAAe,IAAMyB,oBAAoBC,gBAE3D,GAAuB,WAAvBK,SAASS,WACT,OAAOD,UAGFR,SAAAU,iBAAiB,mBAAoBF,QAClD,CAjCID,CAAqBV,gBAmCzB,SAASc,kBAAkBhB,cAEvB,MAAMa,QAAU,IAAMvC,gBAAe,IAAMyB,oBAAoBC,gBAE3D,GAAuB,YAAvBK,SAASS,WACT,OAAOD,UAGJF,OAAAI,iBAAiB,OAAQF,QACpC,CA3CIG,CAAkBb,aAGdC,6BAA6Ba,OAAS,EAAG,CACzC,MAAMC,GAAK,IAAIC,sBACX,CAACC,QAASC,YACED,QAAAzB,SAAS2B,QACb,GAAIA,MAAMC,eAAgB,CACtB,MAAMnC,MAAQkC,MAAME,OACpBrC,gBAAgBC,OAChBiC,SAASI,UAAUrC,MACtB,OAGT,CAAEsC,WAAY,sBAGWtB,6BAAAT,SAASP,QAClC8B,GAAGS,QAAQvC,SAElB,CACL,CAsCAd,eAAe2B,eACfI,SAASU,iBAAiB,mBAAoBd,eAE9CI,SAASU,iBAAiB,wBAAwB,IAAMzC,eAAe2B,iBAIhE,MAAM2B,eAAiB3B,cCxJxB4B,eAAN,MAAMA,uBAAsBC,YAGxB,WAAAC,UAEC,CAED,8BAAOC,CAAwBC,UAAWC,MAAO3D,UAC7C,IAAK4D,KAAKC,iBAAiBF,OAAQ,CAC/B,MAAMG,SAAWhC,SAASU,iBAAiBmB,OAAQI,YAC1CH,KAAAI,YAAYL,MAAOI,cAGvBH,KAAAC,iBAAiBF,OAAS,CAC3BG,kBACAG,SAAU,CAAE,EAEnB,CAEK,MAAAC,gBAAkBN,KAAKC,iBAAiBF,OAEzCO,gBAAgBD,SAASP,aACVQ,gBAAAD,SAASP,WAAa,IAG1CQ,gBAAgBD,SAASP,WAAWzB,KAAKjC,SAC5C,CAED,wBAAagE,CAAYL,MAAOI,WFhCpC,IAAAjD,GEiCQ,MAAMqD,WAAaC,OAAOC,KAAKT,KAAKC,iBAAiBF,OAAOM,UAEtDK,IAAM,IAAIC,IAAInC,OAAOoC,SAASC,OAEhC,OAAA3D,GAAA,MAAAiD,eAAA,EAAAA,UAAWW,aAAX,EAAA5D,GAAmB6D,UACnBL,IAAIM,aAAaC,IAAI,UAAWd,UAAUW,OAAOC,QAAQG,IAG7DR,IAAIM,aAAaC,IAAI,WAAYV,WAAWY,KAAK,MAEjD,MAAMC,kBAAoBpB,KAAKqB,iBAAiBX,KAErCH,WAAA/C,SAASsC,YACQE,KAAKC,iBAAiBF,OAAOM,SAASP,WAE9CtC,SAASpB,WACZA,SAAAgF,YAAYtB,iBAGhC,CAED,6BAAauB,CAAiBX,KAGnB,aAFmBY,MAAMZ,KAAKa,MAAMC,KAAQA,IAAIC,QAG1D,CAED,gCAAOC,CAA0B5B,UAAWC,OAClC,MAAAO,gBAAkBN,KAAKC,iBAAiBF,cAEvCO,gBAAgBD,SAASP,WAEqB,IAAjDU,OAAOC,KAAKH,gBAAgBD,UAAUvB,SAC7BZ,SAAAyD,oBAAoB5B,MAAOO,gBAAgBJ,iBAC7CF,KAAKC,iBAAiBF,OAEpC,CAED,iBAAA6B,GACS5B,KAAAD,MAAQC,KAAK6B,aAAa,cAE1B7B,KAAKkB,IAKLlB,KAAA8B,QAAU9B,KAAK+B,QAAQ,oBACvB/B,KAAAF,UAAYE,KAAK8B,QAAQZ,GAC9BlB,KAAKgC,iBAAmBhC,KAAKF,UAAUmC,QAAQ,mBAAoB,IAEhC,UAA/BjC,KAAKpD,QAAQsF,gBACblC,KAAKmC,UAAYnC,KAAK8B,QAAQM,cAAc,uBACxCpC,KAAKmC,YACLnC,KAAKqC,YAAcrC,KAAKmC,UAAUN,aAAa,uBAIzCnC,eAAAG,wBACVG,KAAKgC,iBACLhC,KAAKD,MACLC,KAAKsC,cAAcC,KAAKvC,QAlBxBtC,QAAQD,MAAM,kDAoBrB,CAED,oBAAA+E,GACI9C,eAAcgC,0BAA0B1B,KAAKF,UAAWE,KAAKD,MAChE,CAED,aAAAuC,CAAcG,MACVzC,KAAK0C,WAAWD,MAEZzC,KAAKmC,WACLnC,KAAKkC,gBAET/F,gBAAe,wBAEZ,IAEE6D,KAAA2C,cACD,IAAIC,YAAY,yBAA0B,CACtCC,SAAS,EACT/B,OAAQ,CACJhB,UAAWE,KAAKF,UAChBkC,iBAAkBhC,KAAKgC,oBAItC,CAED,aAAAE,GACI1D,OAAOsE,QAAQC,MAAM1C,SAAS2C,OAAOhD,KAAKmC,WAE1C,MAAMc,aAAejD,KAAK8B,QAAQM,cAAc,uBAAuBpC,KAAKqC,iBAEvEY,cAQLjD,KAAKmC,UAAYc,aAEjBzE,OAAOsE,QAAQC,MAAM1C,SAAS6C,KAAKlD,KAAKqC,YAAarC,KAAKmC,YAT9CzE,QAAAD,MACJ,6EAA6EuC,KAAKqC,yCAS7F,CAED,gBAAMK,CAAWD,MACT,IACA,IAAKA,KAKD,YAJQ/E,QAAAD,MACJ,sEACAuC,KAAKgC,kBAKP,MAAAmB,OAAS,IAAIC,UAGbC,YAFMF,OAAOG,gBAAgBb,KAAM,aAEjBc,eAAevD,KAAKkB,IAEvCmC,aACO3F,QAAAD,MACJ,8DAA8DuC,KAAKkB,kDAI3ElB,KAAKwD,UAAYH,YAAYG,SAChC,OAAQ/F,OACGC,QAAAD,MAAM,4DAA6DA,MAC9E,CACJ,qIAjKCiC,oCACK,+BAAmB,CAAA,GAD9B,IAAM+D,cAAN/D,eAoKAgE,eAAeC,OAAO,kBAAmBF,eCzJzC,MAAMhH,gBACK,QADLA,2BAEgB,yBAFhBA,mCAGwB,4BAHxBA,uBAIY,gBAJZA,uBAMY,sBANZA,oBAOS,mBAPTA,wBAQa,uBARbA,yBASc,wBAGpB,MAAMmH,wBAAwBjE,YAC1B,WAAAC,WAEII,KAAK6D,QAAU7D,KAAK6D,QAAQtB,KAAKvC,MACjCA,KAAK8D,SAAW9D,KAAK8D,SAASvB,KAAKvC,MACnCA,KAAK+D,SAAW/D,KAAK+D,SAASxB,KAAKvC,KACtC,CAED,iBAAA4B,GACS5B,KAAAgE,SAAWhE,KAAK6B,aAAa,kBAElC7B,KAAKiE,eAEAjE,KAAAkE,QAAUlE,KAAKmE,aAEfnE,KAAAoE,MAAMC,MAAMC,QAAU,IAC3BtE,KAAKuE,aAAa3F,iBAAiB,QAASoB,KAAK6D,SAEjD7D,KAAKoE,MAAMxF,iBAAiB,aAAcoB,KAAK+D,UAExCvF,OAAAI,iBAAiB,SAAUoB,KAAK8D,UACvC9D,KAAKwE,WACR,CAED,SAAAA,GACIxE,KAAKyE,eAEL,MAAM/F,QAAU,KACRsB,KAAKgE,UACLhE,KAAKoE,MAAMM,aAAa,WAAY1E,KAAK2E,gCAGzC3E,KAAKkD,QAITlD,KAAK4E,sBAGL5E,KAAK6E,kBAAkBnG,QAE9B,CAED,SAAAkG,GACU,MAAAE,KAAO9E,KAAK+E,wBAClB,OAAOD,KAAKE,MAAQ,GAAKF,KAAKG,OAAS,CAC1C,CAED,iBAAAJ,CAAkBzI,UACd,MAAM8C,SAAW,IAAIF,sBAAsBC,UAC/BA,QAAAzB,SAAS2B,QACTA,MAAMC,gBAAkBY,KAAK4E,yBAG7B1F,SAASgG,oBAKrBhG,SAASM,QAAQQ,KACpB,CAED,YAAAiE,GACIjE,KAAKoE,MAAQpE,KAAKoC,cAAc3F,iBAChCuD,KAAKmF,gBAAkBnF,KAAKoC,cAAc3F,4BACrCuD,KAAKoE,QAEVpE,KAAKjD,OAASiD,KAAKoC,cAAc3F,wBAEjCuD,KAAKuE,aAAevE,KAAKoC,cAAc3F,oCACvCuD,KAAKoF,SAAWpF,KAAKoC,cAAc3F,wBAEnCuD,KAAKqF,SAAWrF,KAAKoC,cAAc3F,qBACnCuD,KAAKsF,YAActF,KAAKoC,cAAc3F,yBACtCuD,KAAKuF,aAAevF,KAAKoC,cAAc3F,0BAC1C,CAED,UAAA0H,GACW,OAAA9G,MAAMC,KAAK0C,KAAKmF,gBAAgBK,QAAQrH,iBAAiB,WAAWsH,KAAKC,IAAO,CACnF7I,IAAK6I,EAAE7D,aAAa,YACpB5E,MAAOyI,EAAEzI,SAEhB,CAED,cAAA0I,CAAe9I,KAKX,OAJIA,IAAI+I,WAAW,QACf/I,IAAM,GAAG2B,OAAOoC,SAASiF,WAAWhJ,OAGjC,IAAI8D,IAAI9D,IAAK2B,OAAOoC,SAASC,MAAMA,IAC7C,CAED,YAAA4D,GACI,MAAMqB,MAAQ9F,KAAKkE,QAAQ6B,MAAML,GAAMA,EAAEzI,OAAS+I,WAAWN,EAAEzI,OAAOgJ,UAChEC,SAAWlG,KAAKkE,QAAQ6B,MAAML,IAAOA,EAAEzI,QACvCkJ,SAAWL,OAASI,UAAYlG,KAAKkE,QAAQ,IAAIrH,IAEvD,IAAKsJ,QAAS,OAER,MAAAC,aAAepG,KAAK2F,eAAeQ,SAErC,GAAAnG,KAAKoE,MAAMvH,IAAK,CAEhB,GADyBmD,KAAK2F,eAAe3F,KAAKoE,MAAMvH,OAC/BuJ,aAAc,MAC1C,CAEDpG,KAAK2E,cAAgBwB,OACxB,CAED,IAAAjD,GACQ,GAAAlD,KAAKoE,MAAMvH,IAAK,CAChB,MAAMuJ,aAAepG,KAAK2F,eAAe3F,KAAK2E,eAE9C,GADyB3E,KAAK2F,eAAe3F,KAAKoE,MAAMvH,OAC/BuJ,aAAc,MAC1C,CAEIpG,KAAAoE,MAAMvH,IAAMmD,KAAK2E,aACzB,CAED,QAAAb,GACIuC,aAAarG,KAAKsG,cACbtG,KAAAsG,aAAehK,YAAW,KAC3B0D,KAAKyE,eACLzE,KAAKkD,QACYlD,KAAKoE,MAAMmC,QACjBvG,KAAKoE,MAAMoC,OAAOC,OAAM,WACpC,IACN,CAED,OAAA5C,CAAQ6C,GACAA,EAAErH,OAAO0C,QAAQ,uBACjB/B,KAAK2G,cAEL3G,KAAK4G,YAEZ,CAED,UAAAA,GACI5G,KAAKoE,MAAMmC,OAASvG,KAAKoE,MAAMoC,OAAOC,OAAM,SAAYzG,KAAKoE,MAAMyC,QACnE7G,KAAK8G,kBACR,CAED,WAAAH,GACI3G,KAAKoE,MAAM2C,OAAS/G,KAAKoE,MAAM2C,MAC/B/G,KAAK8G,kBACR,CAED,QAAA/C,GACQ/D,KAAKjD,SACAiD,KAAAjD,OAAOsH,MAAMC,QAAU,KAE3BtE,KAAAoE,MAAMC,MAAMC,QAAU,IACvBtE,KAAKoE,MAAMhG,aAAa,cACxB4B,KAAKoE,MAAM2C,OAAQ,EACnB/G,KAAKoE,MAAMoC,OAAOC,OAAM,UAE5BzG,KAAK8G,kBACR,CAED,gBAAAA,GACQ9G,KAAKqF,UACLrF,KAAKqF,SAAS2B,UAAUC,OAAO,UAAWjH,KAAKoE,MAAMmC,QAErDvG,KAAKsF,aAAetF,KAAKuF,eACzBvF,KAAKsF,YAAY0B,UAAUC,OAAO,SAAUjH,KAAKoE,MAAM2C,OACvD/G,KAAKuF,aAAayB,UAAUC,OAAO,UAAWjH,KAAKoE,MAAM2C,OAEhE,CAED,oBAAAvE,GHpMJ,IAAAtF,GGqMa8C,KAAA2B,oBAAoB,QAAS3B,KAAK6D,SACvC,OAAA3G,GAAA8C,KAAKoF,WAALlI,GAAeyE,oBAAoB,QAAS3B,KAAKkH,SACjDlH,KAAKoE,MAAMzC,oBAAoB,aAAc3B,KAAK+D,UAC3CvF,OAAAmD,oBAAoB,SAAU3B,KAAK8D,SAC7C,EAGLJ,eAAeC,OAAO,mBAAoBC,iBC5M1C1F,SAASU,iBAAiB,oBAAoB,KACjCV,SAAAU,iBAAiB,SAAUuI,MAC1B,MAAAC,KAA8B,MAAvBD,IAAI9H,OAAOjC,QAAkB+J,IAAI9H,OAAS8H,IAAI9H,OAAO0C,QAAQ,KACtEqF,MAAyB,MAAjBA,KAAKhK,SAAmBoB,OAAOoC,SAASyG,WAAa,IAAI1G,IAAIyG,KAAKvG,MAAMwG,WAChFD,KAAK/H,OAAS,aAKbnB,SAAAU,iBAAiB,SAAUuI,MAEL,MAAvBA,IAAI9H,OAAOjC,SACXoB,OAAOoC,SAASyG,WAAa,IAAI1G,IAAIwG,IAAI9H,OAAOwB,MAAMwG,UACtDF,IAAI9H,OAAOwB,KAAKyG,SAAS,OAEzBpJ,SAASqJ,qBAAqB,QAAQ,GAAGlD,MAAMmD,eAAiB,SAChElL,YAAW,KACP4B,SAASqJ,qBAAqB,QAAQ,GAAGlD,MAAMmD,eAAiB,KACjE,YCjBfhJ,OAAOuE,MAAQvE,OAAOuE,OAAS,GAM/BrF,QAAQ+J,IAAI,yBAGZvJ,SAASyE,cAAc,IAAIC,YAAY,iBACvCpE,OAAOuE,MAAM2E,QAAS"}